# coding: utf-8
# Copyright (c) Max-Planck-Institut f√ºr Eisenforschung GmbH - Computational Materials Design (CM) Department
# Distributed under the terms of "New BSD License", see the LICENSE file.

import numpy as np
from scipy.interpolate import CubicSpline
from scipy.integrate import cumtrapz

class GenerateBondingPotential():
    """
    !!! This class is currently in an experimental state and undergoes frequent updates. 
        Please be cautious when using it. -rads !!!
    
    
    Generates the 'local approximation' (LA) potential and force functions for a NN shell.
    
    This is done by displacing an atom i along 1 longitudinal and 2 transversal vectors, 
    and collecting the forces on atom j projected along these vectors. The longitudinal and transversal vectors are 
    the basis vectors of the atom j. 
    
    Takes as inputs all necessary data for the shell (generated using StaticBondAnalysis) and returns cubic spline 
    fits for the LA potential and force along the basis vectors.
    
    Parameters:
    - ref_job (object): The reference job object.
    - b_0 (float): The bond length for the NN shell.
    - basis (list): The basis vectors of atom j.
    - rotations (list): The rotation matrices which transform atom j to the equivalent atoms in the same shell.
    - jth_atom_id (int): The atom id of atom j. The forces on this atom will be used to generate the LA potential/forces.
    - ith_atom_id (int): The atom id of atom i. This atom will be displaced.
    - long_disp_low (float): This value will be subtracted off of b_0 to set the lower limit of the longitudinal 
                             displacement. Default is -0.5.
    - long_disp_hi (float): This value will be added to b_0 to set the upper limit of the longitudinal displacement. Default is 1.5.
    - t_disp_low (float): This value will be subtracted off of 0 to set the lower limit of the transversal 
                          displacement. Default is 0.
    - t_disp_hi (float): This value will be added to 0 to set the upper limit of the transversal displacement. Default is 1.
    - n_long (int): The number of samples for longitudinal displacement. Default is 10 samples.
    - n_t (int): The number of samples for transversal displacement. Default is 10 samples.
    - energy_offset (float): The energy offset that is added to the LA bonding potential. Default is 0.
    - deg (int): If deg is not None, then perform a polynomial fit of degree 'deg' for the transveral components.
    """
    
    def __init__(self, ref_job, b_0, basis, rotations, jth_atom_id, ith_atom_id=0, long_disp_low=-0.5, long_disp_hi=1.5, 
                 t_disp_low=0., t_disp_hi=1., n_long=10, n_t=10, energy_offset=0., deg=None):
        self.ref_job = ref_job
        self.structure = ref_job.structure
        self.b_0 = b_0
        self.basis = np.array(basis)
        self.rotations = np.array(rotations)
        self.jth_atom_id = jth_atom_id
        self.ith_atom_id = ith_atom_id
        self.long_disp_low = long_disp_low
        self.long_disp_hi = long_disp_hi
        self.t_disp_low = t_disp_low
        self.t_disp_hi = t_disp_hi
        self.n_long = n_long
        self.n_t = n_t
        self.energy_offset = energy_offset
        self.deg = deg
        
        self._project = self.ref_job.project.create_group('base_' + str(np.round(self.b_0, decimals=5)))
        self._long_hat = basis[0]
        self._t1_hat = basis[1]
        self._t2_hat = basis[2]
        self._long_pos = None
        self._t1_pos = None
        self._t2_pos = None
        self._long_force_on_j = None
        self._t1_force_on_j = None
        self._t2_force_on_j = None       
        
    @staticmethod
    def displace_atom(position_of_the_atom, direction, disp_low, disp_hi, n_samples):
        """
        Displaces an atom along a given direction (unit vector) to generate a set of atom positions.
        
        Parameters:
        - position_of_the_atom (array-like): The initial position of the ith atom.
        - direction (array-like): The displacement direction (unit vector).
        - disp_low (float): The lower limit of the displacement.
        - disp_hi (float): The upper limit of the displacement.
        - n_samples (int): The number of samples for the displacement.
        
        Returns:
        - array-like: An array of atom positions generated by displacing the atom along the given direction.
        """
        if disp_low < 0.:
            # if the disp_low is < 0 (which would always be the case for the longitudinal direction and not always for the transversal
            # direction, we make sure to include 'b_0' (for longitudinal and 0. for transversal) in the samples. In this case, the 
            # samples are not evenly spaced!
            low_samples = np.linspace(disp_low, 0., int(n_samples/2), endpoint=False)
            hi_samples = np.linspace(0., disp_hi, int((n_samples+1)/2))
            samples = np.concatenate((low_samples, hi_samples))
        else:
            samples = np.linspace(disp_low, disp_hi, n_samples)
        return np.array([position_of_the_atom-direction*s for s in samples])
    
    def generate_atom_positions(self):
        """
        Generates and stores the 0th atom positions along the longitudinal and 2 transversal directions.
        """
        self._long_pos = self.displace_atom(self.structure.positions[self.ith_atom_id], self._long_hat, disp_low=self.long_disp_low,
                                            disp_hi=self.long_disp_hi, n_samples=self.n_long)
        self._t1_pos = self.displace_atom(self.structure.positions[self.ith_atom_id], self._t1_hat, disp_low=self.t_disp_low, 
                                          disp_hi=self.t_disp_hi, n_samples=self.n_t)
        self._t2_pos = self.displace_atom(self.structure.positions[self.ith_atom_id], self._t2_hat, disp_low=self.t_disp_low, 
                                          disp_hi=self.t_disp_hi, n_samples=self.n_t)
    
    def _run_jobs(self, positions, tag, delete_existing_jobs=False):
        """
        Runs a static calculation for a structure with the 0th atom position replaced by each entry in positions, for the 'tag' direction.
        
        Parameters:
        - positions (array-like): The positions of the 0th atom.
        - tag (str): 'long', 't1' or 't2'.
        """
        def run_job():
            job = self.ref_job.copy_template(project=pr_tag, new_job_name=job_name)
            job.structure.positions[self.ith_atom_id] = pos
            job.calc_static()
            job.run()
            
        pr_tag = self._project.create_group(tag)
        job_list = pr_tag.job_table().job.to_list()
        job_status = pr_tag.job_table().status.to_list()
        for i, pos in enumerate(positions):
            job_name = tag + '_' + str(i)
            if job_name not in job_list:
                run_job()
            elif job_status[i] != 'finished' or delete_existing_jobs:
                pr_tag.remove_job(job_name)
                run_job() 

    def run_jobs(self, delete_existing_jobs=False):
        """
        Runs static calculation jobs for the longitudinal and 2 transversal directions.
        """
        self.generate_atom_positions()
        self._run_jobs(positions=self._long_pos, tag='long', delete_existing_jobs=delete_existing_jobs)
        self._run_jobs(positions=self._t1_pos, tag='t1', delete_existing_jobs=delete_existing_jobs)
        self._run_jobs(positions=self._t2_pos, tag='t2', delete_existing_jobs=delete_existing_jobs)
        
    def _load_jobs(self, tag, n_samples):
        """
        Loads the static calculation jobs for the 'tag' direction.
        
        Parameters:
        - tag (str): 'long', 't1' or 't2'.
        - n_samples (int): The number of samples for the jobs.
        
        Returns:
        - list: A list of loaded jobs.
        """
        pr_tag = self._project.create_group(tag)
        jobs = []
        for i in range(n_samples):
            jobs.append(pr_tag.inspect(tag + '_' + str(i)))
        return jobs
    
    def load_jobs(self):
        """
        Loads static calculation jobs for the longitudinal and 2 transversal directions.
        
        Returns:
        - tuple: A tuple containing the lists of loaded jobs for longitudinal, t1, and t2 directions.
        """
        self.generate_atom_positions()
        long_jobs = self._load_jobs(tag='long', n_samples=self.n_long)
        t1_jobs = self._load_jobs(tag='t1', n_samples=self.n_t)
        t2_jobs = self._load_jobs(tag='t2', n_samples=self.n_t)
        return long_jobs, t1_jobs, t2_jobs
    
    def _force_on_j(self, jobs):
        """
        Returns the forces on the jth atom.

        Parameters:
        - jobs (list): A list of job objects.

        Returns:
        - array-like: An array of forces on the jth atom.
        """
        return np.array([job['output/generic/forces'][-1][self.jth_atom_id] for job in jobs])
    
    def get_force_on_j(self):
        """
        Retrieves and stores the forces on the jth atom along longitudinal and 2 transversal directions.
        """
        long_jobs, t1_jobs, t2_jobs = self.load_jobs()
        self.long_force_on_j = self._force_on_j(long_jobs)
        self.t1_force_on_j = self._force_on_j(t1_jobs)
        self.t2_force_on_j = self._force_on_j(t2_jobs)
    
    def find_mic(self, vectors):
        """
        Applies minimum image convention (MIC) to a set of vectors to account for periodic boundary conditions (PBC).

        Parameters:
        - vectors (array-like): An array of vectors.

        Returns:
        - array-like: An array of vectors with MIC applied.
        """
        cell=self.structure.cell
        pbc=self.structure.pbc
        vecs = np.asarray(vectors).reshape(-1, 3)
        if any(pbc):
            vecs = np.einsum('ji,nj->ni', np.linalg.inv(cell), vecs)
            vecs[:, pbc] -= np.rint(vecs)[:, pbc]
            vecs = np.einsum('ji,nj->ni', cell, vecs)
        return vecs.reshape(np.asarray(vectors).shape)
    
    @staticmethod
    def orthogonalize(matrix):
        """
        Orthogonalizes a matrix using the Gram-Schmidt process.

        Parameters:
        - matrix (array-like): The matrix to be orthogonalized.

        Returns:
        - array-like: The orthogonalized matrix.
        """
        orth_matrix = matrix.copy()
        orth_matrix[1] = matrix[1] - (orth_matrix[0]@matrix[1])/(orth_matrix[0]@orth_matrix[0])*orth_matrix[0]
        orth_matrix[2] = matrix[2] - (orth_matrix[0]@matrix[2])/(orth_matrix[0]@orth_matrix[0])*orth_matrix[0] \
                                   - (orth_matrix[1]@matrix[2])/(orth_matrix[1]@orth_matrix[1])*orth_matrix[1]
        return orth_matrix/np.linalg.norm(orth_matrix, axis=-1)[:, np.newaxis]
    
    def get_ij_bond_force(self, i_atom_positions, j_atom_forces):
        """
        Computes the bond forces along the line connecting atoms i and j (which is r). Corresponds to the 'central' forces. 

        Parameters:
        - i_atom_positions (array-like): Positions of the ith atom.
        - j_atom_forces (array-like): Forces on the jth atom.

        Returns:
        - tuple: A tuple containing the magnitudes of displacements, displacement directions, and bond forces.
        """
        j_position = self.structure.positions[self.jth_atom_id]
        ij = self.find_mic(j_position-i_atom_positions)
        r = np.linalg.norm(ij, axis=-1)
        ij_direcs = ij/r[:, np.newaxis]
        F_ij = (j_atom_forces*ij_direcs).sum(axis=-1)
        return r, ij_direcs, F_ij
    
    def get_t_bond_force(self, tag='t2'):
        """
        Computes the bond forces along a transversal direction.
        
        For a displacement 'u' along a transversal direction, one has to remember that there is also a displacement r = sqrt(u**2+b_0**2)
        along the ij or 'r' or 'central' direction that needs to accounted for. The force on atom j for a displacement u along a 
        transversal direction is then F_j = F_t(u) + F_ij(r), where we take ij to be the longitudinal direction l with 0 transversal
        displacement. The true transversal force F_t(u) is then F_j - F_ij(r).
        
        Further, for each transversal displacment u != 0, ij is not perpendicular to the original transversal direction anymore. By using 
        the Gram-Schmit method, we can orthogonalize the transversal direction to ij and parameterize the forces along this new 
        transversal direction 't_prime' as 'F_t_prime'. While the effect of this orthogonalization is minimial, we by default will still 
        consider this for the parameterization.

        Parameters:
        - tag (str): 't1' or 't2'.

        Returns:
        - tuple: A tuple containing the displacements u and bond forces F_t_prime along the 'tag' direction.
        """
        if tag=='t1':
            positions = self._t1_pos
            force_on_j = self.t1_force_on_j
            v_id = 1
        elif tag=='t2':
            positions = self._t2_pos
            force_on_j = self.t2_force_on_j
            v_id = 2
        else:
            raise ValueError
            
        r, ij_direcs, F_ij_mags = self.get_ij_bond_force(i_atom_positions=positions, j_atom_forces=force_on_j)
        u = ij_direcs*r[:, np.newaxis]@self.basis[v_id]
        F_t = force_on_j - ij_direcs*F_ij_mags[:, np.newaxis]  
        
        F_t_prime = []
        for ij_dir, f_t in zip(ij_direcs, F_t):
            basis_copy = self.basis.copy()
            basis_copy[0] = ij_dir
            t_prime = self.orthogonalize(basis_copy)[v_id]
            F_t_prime.append(f_t@t_prime)
        F_t_prime = np.array(F_t_prime)
        
        # take F_t_prime == F_t 
        # F_t_prime = np.linalg.norm(F_t, axis=-1)

        if self.t_disp_low == 0.:
            u = np.concatenate((-np.flip(u)[:-1], u))
            F_t_prime = np.concatenate((-np.flip(F_t_prime)[:-1], F_t_prime))
            
        return u, F_t_prime
    
    def _get_potential(self, bonds, force, tag='long'):
        """
        Computes the potential energy from the bond length and bond force. Also subtracts the energy offset, if any.

        Parameters:
        - bonds (array-like): The bond lengths.
        - force (array-like): The bond forces.
        - tag (str): 'long', 't1', or 't2'.

        Returns:
        - array-like: The potential energy.
        """
        if tag == 'long':
            arg_b_0 = np.argmin(abs(bonds-self.b_0))
        elif tag in ['t1', 't2']:
            arg_b_0 = np.argmin(abs(bonds))
        else:
            raise ValueError
        up = cumtrapz(y=-force[arg_b_0:], x=bonds[arg_b_0:], initial=0.)
        down = np.flip(cumtrapz(y=-np.flip(force[:arg_b_0+1]), x=np.flip(bonds[:arg_b_0+1])))
        potential = np.concatenate((down, up))
        if tag == 'long':
            return potential+self.energy_offset
        return potential
    
    def get_all_bond_force_pot(self):
        """
        Computes bond forces and potentials for the longitudinal and 2 transversal directions.

        Returns:
        - list: A list of lists containing the bond lengths, bond forces, and potentials for each direction.
        """
        # long
        long_bonds, _, long_force = self.get_ij_bond_force(i_atom_positions=self._long_pos, j_atom_forces=self.long_force_on_j)
        long_pot = self._get_potential(long_bonds, long_force, tag='long')
        ij_force_eqn = CubicSpline(long_bonds, long_force)
        # t1
        t1_bonds, t1_force = self.get_t_bond_force(tag='t1')
        t1_pot = self._get_potential(t1_bonds, t1_force, tag='t1')
        # t2
        t2_bonds, t2_force = self.get_t_bond_force(tag='t2')
        t2_pot = self._get_potential(t2_bonds, t2_force, tag='t2')
        return [[long_bonds, -long_force, long_pot],
                [t1_bonds, -t1_force, t1_pot],
                [t2_bonds, -t2_force, t2_pot]]
    
    @staticmethod
    def get_spline_fit(data):
        """
        Performs a cubic spline fit to the given data.

        Parameters:
        - data (list): A list of bond lengths, bond forces, and potentials.

        Returns:
        - tuple: A tuple containing the cubic spline functions for bond force and potential.
        """
        force = CubicSpline(data[0], data[1])
        potential = CubicSpline(data[0], data[2])
        return force, potential
    
    @staticmethod
    def get_poly_fit(data, deg=4):
        """
        Performs a polynomial fit to the given data.

        Parameters:
        - data (list): A list of bond lengths, bond forces, and potentials.
        - deg (int): The degree of the polynomial fit (default is 4).

        Returns:
        - tuple: A tuple containing the polynomial functions for bond force and potential.
        """
        force = np.poly1d(np.polyfit(data[0], data[1], deg=deg))
        potential = np.poly1d(np.polyfit(data[0], data[2], deg=deg))
        return force, potential
    
    def get_bonding_forces_potential(self):
        """
        Computes the bonding forces and potentials for the longitudinal and 2 transverse directions.

        Returns:
        - tuple: A tuple containing the longitudinal, t1, and t2 bonding forces and potential functions (CubicSpline or polynomial).
        """
        self.get_force_on_j()
        data = self.get_all_bond_force_pot()
        long_force, long_potential = self.get_spline_fit(data[0])
        if self.deg is not None:
            t1_force, t1_potential = self.get_poly_fit(data[1], deg=self.deg)
            t2_force, t2_potential = self.get_poly_fit(data[2], deg=self.deg)
        else:
            t1_force, t1_potential = self.get_spline_fit(data[1])
            t2_force, t2_potential = self.get_spline_fit(data[2])
        return long_potential, t1_potential, t2_potential, long_force, t1_force, t2_force
